Building Laravel and Vue.js Web Apps: Module 1: Introduction: Laravel and Vue.js--Achieving full-stack elegance:
- [Michael] With the number of PHP frameworks currently in existence, it was no small feat for Laravel to grow to become the most popular choice among PHP developers. Its powerful abstractions, built in security features, incredibly useful command line interface, and vibrant ecosystem allow us to build more robust applications while writing less code. Vue.js ships with Laravel and is included in all new projects as the default JavaScript framework. Vue makes it easy to create dynamic user interfaces, build single page applications, and manage state complexity using flux-like architectures.

All of which we'll implement in this course. I'm Mike Sullivan. I've been a professional web developer for over 15 years, and these days I'm quite happy with my frameworks of choice for backend and front-end development. Join me for this LinkedIn Learning course to find out how effective and rewarding it can be to build real-world applications with the power and elegance of Laravel and Vue.js.

Building Laravel and Vue.js Web Apps: Module 1: Introduction: Demo Project Overview:
- [Instructor] In this course we'll imagine that we've been hired by Nadia's Garden Restaurant to build out their website. We've been provided with HTML, CSS, and image assets, but they want us to build a dynamic site with a custom admin tool for editing the menu, which is the part of the site that will change most frequently. We'll set up a new Laravel project and integrate the Nadia's Garden design. We'll build a tool to manage the categories and control their appearance on the home page. Then we'll integrate the category manager into a larger single-page application for managing the entire menu with client side routing using Vue Router and state management using Vuex.

All supported by a robust and secure Laravel backend. Including a flexible API that can be used by third-party sites or apps. So if you're ready to find out how we'll put all this together with Laravel and Vue.js, then I`ll see you in chapter one.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Installing Homestead:
- [Instructor] In this video, we'll begin to set up a complete development environment fr Laravel in Vue.js. On the Laravel.com home page, if you click Documentation up here, one of the first things that you'll see mentioned is Laravel Homestead. Homestead is a virtual machine, actually an Ubuntu Linux machine, that comes prepackaged with everything you need to build websites with Laravel in Vue.js and run them locally. Homestead is a Vagrant box, which means we'll be using a piece of software called Vagrant to create and manage this virtual machine.

On the Get Started page, they mention that Vagrant alone can't handle everything. We also need a virtualization provider to actually run the virtual machine that we're going to manage with Vagrant. One good option in this list that's available on multiple platforms is VirtualBox. If you're trying to follow along and you haven't worked with Vagrant before, you may want to pause the video here while you install Vagrant and VirtualBox because I won't be going through that entire process, and it's straightforward for most users.

If you do hit any snags, I would suggest first carefully reading this Getting Started page and following the links, especially the one here for install the latest version of Vagrant. But one common gotcha that you'll see mentioned in the Laravel docs is in this red section down here. If you're a Windows user, you'll need to make sure that hardware virtualization is enabled in your BIOS settings. Now we're going to head over to the command line.

I'll be using PowerShell in this course. And if you're also using Windows, I would strongly suggest that whatever terminal you're using, that you launch it by right-clicking and choosing Run as administrator. Also, before I forget, I have a shortcut for Visual Studio Code down here, which we'll be using in this course, and I want to right-click that and choose Properties, Advanced, and make sure that Run as administrator is also checked here because if you don't do this, you will probably run into issues later on with permissions when we have to create symbolic links in our project, which are going to help us manage user uploaded files, such as images for the menu that we're going to build.

So in PowerShell, the first thing that I'm going to do is change to my user directory with cd tilde. And then we can find the command for adding the Homestead box to Vagrant in the Laravel docs. If I scroll down a little bit more, it's Vagrant box add laravel/homestead. So I'm going to copy that and paste it into PowerShell. And it's going to ask us what provider we're going to use and we'll enter 3 for VirtualBox.

This could take a couple minutes, so if you're following along, you may want to let that finish before you go on to the next video. If you've used Vagrant before, and you're hitting any snags at this point, then making sure you're using an up-to-date version of both Vagrant and VirtualBox can usually help sort out most issues. Now that we've added the Homestead box to Vagrant, we'll take a look at configuring and booting it in the next video.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Configuring and booting the virtual machine:
- [Instructor] To finish setting up Homestead, next we need to clone the Homestead repository on GitHub because that contains scripts we need to configure our virtual machine and boot it. We can find that Git clone command in the next section of the Homestead documentation here. So I'm going to copy this, and bring it over to PowerShell, but if you're on Windows using the normal command prompt or PowerShell, don't put the tilde slash here because it will actually create a directory named tilde. Even though you can do cd tilde to change your user directory, that won't work.

So I'm going to clone it like that, and next, we want to check out the latest stable version which we can find on the release page for that repo, and there's a link to it right here. So it looks like it's 7.19.2. I'm going to copy that which corresponds to a Git tag name, and by the way, you could also find that with Git tag on the command line. Let's cd to our cloned Homestead directory, and then do git checkout using that tag as a ref name.

The last thing we need to do before we add our custom settings and boot the machine is initialize Homestead, and that means creating a new Homestead YAML configuration file. If we look in the directory right now, we don't see Homestead.yaml, but we do see these init files here. On Windows, we would want to run the batch file, init.bat, and on Mac and Linux, you'll generally want to do bash init.sh. So I'm going to run init.bat.

Homestead is now initialized, and if we look again, now we do see that Homestead.yaml file. Let's open that up in Visual Studio Code by typing code Homestead.yaml, and if code has been added to your path, that should work. I'm going to enable AutoSave before I forget so that I don't have to keep saving after every change, and in VS Code, we can open up an integrated terminal with control backtick, and again, this is PowerShell for me.

Now we're going to create a new directory called Nadias for our Nadia's Garden Restaurant website. We're doing this now so that we can tell Vagrant to sync the files in this directory with a corresponding directory inside the virtual machine when it boots up. That way, we can edit code in Visual Studio Code on our host machine, but run that code inside the virtual guest machine. So in this YAML configuration file, we can map that directory that we just created to Nadia's directory under our Linux user directory, and you can see that that user is named Vagrant.

For the domain name, something.test is common, but I tend to use a subdomain like dev, and for Nadia's Garden Restaurant, I'm just going to use dev.nadias. Mapping that domain to the public directory in our synced folder, again not code, but nadias, that will configure that as the root directory in an NGINX configuration file for that domain, which is what we would want for a Laravel site. You could leave the database name as is, but I usually change it to something meaningful, so in this case nadias again.

Finally, we need to make sure that the domain name we chose is mapped to this local IP address for the box up here, which I'm going to copy now. We can do that by editing our host file, and on Windows, that should be at c:\Windows\system32\drivers\etc\hosts. On Mac and Linux, it's a little bit easier. It should just be at /etc/host.

So now I can pace that IP address, and make sure that dev.nadias is mapped to that. Back in the YAML file, we'll need to be able to connect to the VM using SSH, but if you don't already have an SSH key in this folder, you can just comment out the key section with control/, and Vagrant will create and manage the keys for you. So now, again, if we cd to Homestead, we're ready to boot the machine with Vagrant up.

This sometimes takes a couple minutes, so you can pause the video now if you're following along, and I think I'll probably stop reminding you to pause videos all the time since you can probably figure out when you need time to catch up. Now that it's booted up, Vagrant SSH should get us to the bash shell in Homestead, and here we are. In the next video, we'll create a new Laravel project and set up an authentication system.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Scaffolding an authentication system:
- [Instructor] In Homestead, the Laravel installer is already set up for us so to create a new project we can just do, Laravel new nadias. Because our sync nadias directory already exists, we'll want to add the force option to allow it to overwrite that empty directory. Once this is done, we can already navigate to http://dev.nadias, and we should be able to see the default Laravel site. The first thing we'll want to do with our new project, is add it to the VS code workspace.

So from the file menu, I'm going to do add folder to workspace, and in my user directory I'm going to want nadias. You'll find that most backend related items are under App, but not everything. For example, we have the routes folder down here, and lets take a look at web.php. And this is where we define routes that you can navigate to in the browser. Here we have one route route, slash, which serves the welcome view, which you can find in resources, views, welcome.blade.php.

Before we start building out our restaurant site, we're going to generate some user related tables, and authentication system. From inside the homestead box, we can use the infinitely useful Laravel command line interface called artisan. So cd to nadias, and for this task, we just need to do artisan make:auth. Now, if we look at web.php again, we have a /home route, because that's where the user will be redirected after registration or log in.

Also notice that a call to auth:routes has been added, and that's going to set up the routes that are related to log in and registration. We also have some new views under resources, views, off. If I refresh the home page, and click this register link that appears now, and fill out this form, I'm going to get an error though. And that's because we still don't have a users table in our database.

And it's also using homestead for the database name, and remember we want it to use nadias, so lets fix that first. Under config in database.php, this mysql connection is going to be the default and we can see that it's using the environment helper method to get the database name, and using forge as the default if it can't find that environment setting. Changing the default from forge won't fix this, we actually want to change it in our .env file in the route directory down here.

So we're going to change DB_DATABASE to nadias like we wanted, and while we're in here, lets also change APP_NAME to Nadia's Garden Restaurant and make sure you put it in double quotes, and we'll also change APP_URL to dev.nadias here. Next, to create users table, we just need to run the database migrations that have already been prepared for us, which are in the database/migrations directory.

These are like sql scripts written in php. One for creating the users table, and one for creating a password reset tokens table. One thing I want to add in the users table script for later, is a column for indicating an admin level user. This is going to be a bullion column, called is_admin, and we'll make sure that it defaults to false. We run the migrations, with artisan migrate.

Now if I go back, and try this again, I've created a user, and logged in. So now I can register, log in and log out, and in the next video we'll talk about using forgot password, and setting up email verification.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Enabling forgotten password and email verification:
- On the login page, if I click forgot your password and try to submit this form, I'm going to see an authentication error. Because the default SMTP mail driver doesn't have a username and password set yet. But, there's an easy way to view the content of an email without actually sending it. And we can set that up in our environment file. I'm using control P to open that file even though it's right there in the route directory. And now, if we just change the value of mail driver from SMTP to Log, we can log emails instead of trying to send them.

So after refreshing and resubmitting that form, I can view the log. Which is in storage, logs, and it looks like there's just one log file that was created just now. And if I scroll down to the bottom, you can see the email that would be sent if we were using SMTP or perhaps an API. We can even click this link with control click and verify that this feature is working.

In Laravel 5.7, a new email verification feature was added, so that you can be confident that your users are using not only valid email addresses, but also deliverable email addresses. Because users will be required to click a verification link in an email that you send to them upon registration. But you do need to edit a couple files to enable it. So in our user model, in user.php in the app directory, we need to add the must verify email interface here.

Which you can see, has already been imported for you with this use statement here. That will trigger the verification logic on registration, and email a link to the user. Next, in our routes file, our web routes file, we'll need to register some routes for sending verification links and verifying emails when links are clicked. We can do that simply by passing an options array to this Auth routes call here. Where verify has the value true.

Let's try another registration now. I'm going to log out and do a new registration, with a different email this time, obviously. Since it has to be unique I'll use Michael instead of Mike. And at this point I'm logged in, but this new user is not verified yet. And if, for example, we wanted to restrict this home route to verified users only, we can just add the verified middleware to the route like this. Now if I refresh this page, I'm no longer authorized.

We could find that verification link in the logs, but lets see if we can do a little bit better than that this time. You may have noticed in my environment file that the default mail host is mail trap. This is a service that allows us to easily view all emails sent by our site in a web mail inbox. Because they'll all go to the same place regardless of the addressee. So, if we go to mailtrap.io you can sign up for a free plan, for an inbox that can hold up to 50 messages at a time.

Without a credit card. Which is great for testing. So if I click sign up I'm just going to use my google account. And then if I click demo inbox, you can see the username and password that we'd want to enter into our Laravel environment file. So I'm going to copy that and bring it over here. This is going to be the mail username. And this is going to be the mail password. And we need to remember to change mail driver, back to SMTP.

Now if I go back to this page and click, click here to request another, I should actually be able to see this email in my mail trap inbox even though I'm using an example.com email. And there it is. If I click it, now I'm verified and authorized to view this page. Next, we`ll finally start talking about view components while we take a look at Laravel mix.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Using webpack with Laravel Mix:
- [Instructor] Now it's time to take a look at Laravel Mix, which runs on top of the popular webpack module bundler to compile and bundle assets such as JavaScript files and C S S or Sass files. In our layouts file, we see asset here and here. That asset helper method returns an absolute URL with HTTP or HTTPS, depending on the current protocol. Those files are in public, js, and public css, and they're recreated whenever webpack processes changes in the corresponding files in the resources subdirectories.

In this case, resources, jsapp.js, and under sass, this app.sass file here. Let's look inside app.js. First, this loads bootstrap.js, which in turn loads a number of libraries and utilities like Lodash, jQuery, and axios. In app.js, we're also adding Vue to the global scope and registering a global component called example component which is in the components folder here.

And then of course down here, we're mounting our root view instance to a div with the ID app, which is in the layout file that we just looked at. Webpack can be pretty complicated, but configuring it with Laravel Mix is simple. In webpack.mix.js in our root directory, we see a call to mixes js method with a source and target directory. And then a chain call to the Sass method, again with a source and target directory.

Let's see if we can put example component on a page and then edit it. I'm going to accept this suggestion to install the Vidar extension down here so that we have syntax highlighting and error checking for our .vue component files. Once that's done installing, we can click reload to activate it and now we have some nice syntax highlighting for our Vue component file. Let's use the home view to test this and add this component right under this dashboard card here.

And now in the components template, we'll add a single word here and see if we can get it to show up in the browser. If I were to refresh after this change, I do see the component now, but not my edit. That's because webpack is not even running yet and of course the browser doesn't read .vue files on its own. Before we can get webpack running to compile our assets when they change, we need to install some front-end development dependencies.

You usually want to use npm to do that on your host machine because it'll be faster and you can do things like automatically launch browsers and trigger a refresh, which we'll see in the next video. So if you're in the homestead terminal right now, you can just do control + shift + back tick to open a new terminal on your host machine and then we can do npm install as long as we have no js installed on that host machine. Once npm install finishes, we can run webpack using npm scripts that are defined in our package.json file in our root directory.

For example, to run the dev script here, you would type npm run dev on the command line. But you can see that dev is really just an alias for development. That will do a one time development build, but watch is a little bit better for us because it will watch files for changes and automatically recompile them on the fly. So let's try that now. Npm run watch. And you can see it building modules and it's compiled successfully now and it's still running and watching for changes.

By the way, as you're working, if it seems like watch isn't picking up the changes to your files, you may want to try watch-poll instead. So once that's done compiling, I should be able to refresh and see my edit. And try a hard refresh with control + F5 if you don't see the change right away. In the next video, we`ll take a look at a way to avoid refreshing altogether.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Cache busting and Browsersync:
- [Instructor] We'll continue to explore Laravel Mix in this video, while we talk about cache busting, and browser sync. If I continue to edit this file, and then refresh the page, I might not see any changes because the browser will often get the App.js file from its cache. One way to avoid having that be loaded from the cache when there are new changes, is to add a query string with a unique hash to the file name. We can accomplish this by first just adding a call to the version method in our mix file.

In our lay-out file, remember I said that asset just creates an absolute URL, so if we also want to append the unique hash we'll have to change asset to mix here. And lets do that for App.js and App.css. We'll need to stop the running watch process with Control + C and then restart it. And now when I refresh, I see my original change, and if you do View Source you can also see that unique hash appended as a query string.

Let's test a change to our .sas file now. So in Resources, sas app.scss. If I just change this background color to yellow, and I'm going to use one of the variables that's defined in the variables file that sits right next to this one. When I refresh I get that yellow nav bar color, and I can also be pretty confident that a browser won't load an older version of this page when a user tries to refresh it.

Cache busting is really important in production, but we wouldn't really need it during development if we could automatically perform a full page refresh whenever files are changed. And it turns out we can do that. So we could reserve this just for production by saying if mix.inproduction, then only then do we use this versioning feature. And to enable the automatic reloading during development we just need to call mix.browserSync and pass in our local development domain, dev.nadias.

The reason we need to specify our domain here, is that we're actually going to start using a proxy server on the host machine that forwards requests to our homestead server, but also enables the injection of code in each page that can communicate with webpack and trigger the full page refresh whenever files are changed. So again when I stop this process and restart, you're going to see that it's automatically going to open the site through a server running on local host, now.

So I'm going to go back to the home page. That's fine that we're not logged in for now. And then I just want to line up my browser side-by-side with my editor and then back in the .sas file... Watch what happens when I change this back to the white color. So we have VS Code auto saving, then webpack auto compiling, and then the browser auto refreshing. And that's all pretty nice.

Webpack also has a feature called Hot Module Replacement. And that can inject updated modules without a full page refresh. Feel free to disable browser sync and try that by using npm run hot instead. It's a really great feature but I've found that it can be a little bit harder to get it working sometimes, especially when there are more moving parts to deal with, like in a Laravel project like this one where Mix is running on top of webpack. And the other great thing about browser sync, if I go back to the welcome page for a second, is that it can also automatically refresh after PHP changes as well.

So if I open the welcome view here, and just change this to the name of our restaurant site, and then go back to the browser, you can see it's already updated. In the next chapter, we'll start to integrate the Nadia's Garden design and assets and then start building out our View powered menu editor.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Integrating a Layout:
- [Instructor] In this video, we'll start to add the Nadia's Garden Restaurant branding to our Laravel project. In the Web Routes file, let's change this closure for slash to just return the home view, instead of that Laravel welcome view, which we don't need anymore. You can find the Nadia's Garden HTML assets in the exercise files for this video, so I'm going to add that folder to the workspace now, nadias_html.

So now, down here, in index.html, first, let's take a look at the head element here. For the title, let's just copy the restaurant name for now, and then, if I go over to our layout file, app.blade.php in layouts, let's change the default from Laravel to that, and of course, we're going to need to change these to double quotes, since we have that apostrophe there. But, it's going to get this app.name config value from the name key in app.php in the config directory, which uses that environment helper method to get the app.name value we set in the last chapter.

Then, over here, we can yield to a title section in the content pages that use this layout, in case we want to add a page specific part of the title, like a dash with the page name, or in the case of the homepage, this slogan here. We can also remove these font elements in the Laravel layout, and we'll add our favicon.

And, in index.html, let's copy just the URL for this font, and then, we can paste it right into our Sass file, in resources, sass. And we'll just replace this font that we're not going to use for the Nadia site. While we're in here, let's remove Bootstrap, which we're not going to use in this course, and this Laravel rule. You might want to leave Variables around, 'cause it could come in handy, even though we might not get around to using it in this course.

And then, in the nadias_html assets, let's just copy everything in this stylesheet right into our Sass file. So, now we can use Sass features with this CSS, and, for example, anything that begins with the top-bar class, I can nest under that first top-bar selector, and then, remove the top-bar part, like that. Let's also remember to copy the images folder from the assets, into the public Laravel folder, and that will make those images accessible with the source attributes that they already have.

Next, I'm going to remove everything from the Laravel layout file that we don't need, but I'll leave a few things behind, like for instance, this div with id="app" because we need that for our view instance to be mounted on. And, I'm also going to leave these authentication links here, like login, register, and logout, but I'm just going to remove these classes that are no longer available.

So, we have Login and Register, which will appear for guests. Otherwise, I'm not going to deal with displaying the account name for now, I just want the logout link. And you can see, that in Laravel, a logout is performed using a POST request, that's why this forum element is down here, so when someone clicks the logout link, it actually submits that form.

And I'm also going to leave this yield('content') here, because that's what's going to allow our content pages to extend this layout. Now I'm going to paste in this root div, from index.html. Not everything belongs in the layout, but we'll move it there for now. And then we'll start piecing everything together. I don't actually need this div, I just wanted to remember to put id="app" on the root div here, which also has class="container".

So now, let's grab those authentication links, and see if we can integrate them into the existing Nadia's navbar. So this should be fine like that, I just want to add another separator after Contact. Login and Register will appear together, since we do have a register route, so let's put a separator between those.

Otherwise, the Logout link will appear, and that all looks fine now. Now, everything between the two main tags, actually belongs in our home view, so that other pages can also use this layout. So I'm going to replace everything in the content section of our home.blade.php view, and then, back in the layout, between the main tags is where I want to yield to those content pages.

And also, in our home view, let's add that title section that I mentioned before, and instead of ending the section, I can just put the content right in there, like that. So, let's grab that slogan from index.html, and we'll put that in there. Now, if we check the browser, we see our branded homepage, and we can start adding some dynamic behavior to it, over the next few videos.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Creating a model and seeding the database:
- [Instructor] The first thing we'll do with our new homepage is change this section so that the category names and image file names are pulled from the database. So, switch to your homestead shell if you're not there already, by using this dropdown. And we'll use artisan to create a model called category, so artisan make:model Category. And then, with the M and R options, we can also generate at the same time a migration for creating category table in the database and a resource controller with some basic CRUD actions.

So, in my app folder now, I have this category model, and it doesn't need anything else for now except what's provided in the base model class. And in HTTP controllers, in my category controller, I won't use all of these methods, but it's nice to have this shell as a starting point. And then in database migrations, I have this new migration file. And here I'm going to add name and image columns for the category table.

So these will be string or a VARCHAR in MySQL, and we're going to use the default settings for name and image for the image file name. I'll also add a display order column to control the order of the categories on the homepage and on the menu. So this can just be an unsignedTinyInteger, and we'll call it display_order, and that's perfectly appropriate for ordering a small number of items.

And of course, time stamps will add those created-at and updated-at time stamp fields. So now we can run artisan migrate, and we should have a new categories table in our database. We're going to build an admin interface shortly to manage these categories, but for now, we'll use a seeder to get some test data in our new table. So, we can create a new seeder with artisan, artisan make:seeder, and we'll give our seeder class a name like CategoriesTableSeeder.

Now, inside that file that's going to appear in the seeds folder under database, I can use the DB facade with the categories table and call the insert method passing an array of arrays that each correspond to a category model that I want to insert. So for my first category, the name was Starters, and for image, we can assume that this file already exists in the public images folder for now to keep things simple.

Display order is going to be one, and we're not going to worry about created at and updated at for now, although those will be automatically taken care of when we're actually saving models in our app. So let's copy this a couple more times and just add two more categories for now. We'll do Salads, and we should have an image called salad.jpg. Display order will be two. And then Entrees, and if you remember, that one was a picture of a burger.

Display order will be three. And we're going to leave out the desserts' category for now because we'll insert that using our admin tool later. To run this seeder, we could call artisan db:seed and give it the class name with the class option, or we can just run artisan db:seed if we add it to the database seeder. So, we could just uncomment this and change users to categories.

And by the way, if you don't create the seeder with artisan, and you're just starting from the exercise files, you might need to run composer dump-autoload for it to be able to resolve the categories table class name. Otherwise, you should just be able to run artisan db:seed now. And then we can verify that everything looks good in MySQL. Select star from categories. And there they are.

And in the next video, we'll display this data on the homepage.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Building views with Blade templates:
- [Instructor] Now we'll finish up our restaurant home page by using blade templating to display the categories from the database. Let's remove this slash route here and we'll want to use a home controller method to prepare the data for the home view. So we'll just change home to slash here so that we can serve the home page right on the bare domain like we were doing before. And we don't need the verified middleware here since we don't care if users viewing the home page are verified or even authenticated.

Now in various controllers, such as the login controller, there are places where it redirects the user to home but since we don't have home anymore I'm going to use Control + Shift + H to find and replace and I'm going to look for equals space slash home end quotes and just replace that with slash. So if I hit enter now I see the places in these various controllers where the redirect to property is set and I'm going to click this to replace all.

And now that's taken care of. In home controller now, if we go over there we also don't need this off middleware here since again we don't care if someone is authenticated for the actions in this controller. Now in the index method, let's grab all the categories and store them in a variable. So we'll do category and we could use the all method here. But if we want all of them and we want them ordered we can just use order by. And remember we're going to be ordering by our display order column.

And then we'll just call get. Now we want to provide an array of parameters to the view which for now will just be categories categories. Now let's go over to the home view. And we'll make these categories, these article elements dynamic. I promise we'll get into using Vue very shortly, actually in the next video but there's really no reason to use Vue here because although the categories are data driven we don't really have any interactive or dynamic behavior once the page is loaded.

So if I remove all of these articles except one then I can wrap this is a four each using blade syntax. And then we can iterate over the categories. And I'll use cat as my looping variable. So for the HREF attribute for the image, this is going to be a link to slash menu with a fragment identifier that points to a named anchor that we'll set up later. And then inside the double curly braces we just need cat name.

And actually I'm going to use the string slug helper method to change spaces to hyphens and otherwise URL-ify this whole string. So let's copy this HREF attribute to the text link as well. And then for image, we want to keep the slash images and then remember cat image will give us just the file name. And we'll want to do an end for each down here and maybe indent that to make it a little easier to read.

So now let's look at the home page. On the home page now, I see an error because this category class wasn't imported into the home controller. So I'm going to need a use declaration at the top of home controller for category. Otherwise I'll need to do app category. Since adding use declarations is sometimes tedious and error prone, I'm going to install an extension to help with that and also provide IntelliSense and auto completion for PHP.

You'll find most PHP extensions aren't perfect but they will save you some time. So Control + Shift + X to look at extensions and I'm going to search for PHP IntelliPhence with a P-H in the middle. So I'm going to install this one and reload to activate. And you might have to wait a minute for it to do some indexing. But then if I retype category I should be able to hit enter now and I'll get my use declaration at the top there.

You'll also want to do control comma to edit the settings for PHP and disable the basic suggestions in VS code so they don't interfere. Also I don't have PHP installed on Windows, so you may have noticed that message about not being able to validate against a specific PHP installation, and that's fine for now. And if webpack was running, then usually when you reload you'll lose that running process. So let's just do NPM run watch again.

And now we have our homepage with three out of our four categories, but loaded from the database. And in the next video, we'll start to build the admin UI for updating this data.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Injecting props in Vue components:
- [Instructor] In this video, we'll start to build out the Vue.js powered admin tool for updating the restaurant's menu. Because we'll always have a relatively small number of menu categories, and they have a simple set of attributes, we don't really need separate pages for listing, creating, and updating these category records. We'll do it all in a single page using Vue.js. So I'm going to start by copying the body of this method in the home controller into the index method of the category controller that we created.

But this time instead of home, we'll return a new index view that we'll create inside a categories folder, inside an admin folder. We can actually create those new folders in the view all in one shot if we go to resources, view, New File. I can now do admin categories index.blade.php, and it will create that folder structure for me in the new blade file. And let's copy some of the blade directives from home to get us started.

And we'll remove that slogan and just say Categories for the second part of the title. And of course, we're going to want to do endsection here. And for now, we'll just put a level one header that says categories. In our Web Routes file, I'm going to add a Route for /categories that responds to get requests. And those will just be forwarded to that method so Category/Controller@index, and we'll skip the name for now.

We need to be able to do things like add a new category to the list inline or delete a category. And we'll do that all inside a Vue component called category manager. So this is actually all we'll need in our blade view. And by the way, if you don't get that auto closing tag in PHP files, try the Auto Close tag extension, the first one in the list right here, and that will also enable it for Vue files, which is nice.

In resources, js, components, let's create CategoryManager.vue and we'll start with the template. We need to make sure we have a root element, like a div, and then we can put another div inside that and repeat it with a v-for directive to iterate over the categories. So we can do category in categories. And then for now, we'll just display the name.

And remember the double curly braces here, that's vue string interpolation, not to be confused with the similar blade interpolation. We should also provide a unique key for each element to help Vue manage them more efficiently and id is fine for that here. But where does this categories array come from? Well, in the scripts section, where we export the component options, we can declare categories as a prop that will be provided to the component in the view.

But first in app.js, let's just change example component to category manager to get that one registered quickly, since we won't be using example component anymore. And make sure our web pack is still running, of course. When I look down at my terminal, I can see that it is, and now in the view, all we have to do is inject categories as a dynamic prop. Remember to use v bind or the colon in front of categories, since we're not passing a little string here, but an array of categories.

The nice thing here is that all we need to do is put our PHP variable categories inside the double curly braces. And this will actually call JSON in code automatically and properly double in-code HTML entities to avoid any syntax issues. So it really doesn't get much easier than this to pass an array from PHP to JavaScript. So now in the browser, if I just navigate to categories, I can see our category manager component and the list of categories.

In the next video, we'll start building out the UI for the basic CRUD functionality.



