Building Laravel and Vue.js Web Apps: Module 1: Introduction: Laravel and Vue.js--Achieving full-stack elegance:
- [Michael] With the number of PHP frameworks currently in existence, it was no small feat for Laravel to grow to become the most popular choice among PHP developers. Its powerful abstractions, built in security features, incredibly useful command line interface, and vibrant ecosystem allow us to build more robust applications while writing less code. Vue.js ships with Laravel and is included in all new projects as the default JavaScript framework. Vue makes it easy to create dynamic user interfaces, build single page applications, and manage state complexity using flux-like architectures.

All of which we'll implement in this course. I'm Mike Sullivan. I've been a professional web developer for over 15 years, and these days I'm quite happy with my frameworks of choice for backend and front-end development. Join me for this LinkedIn Learning course to find out how effective and rewarding it can be to build real-world applications with the power and elegance of Laravel and Vue.js.

Building Laravel and Vue.js Web Apps: Module 1: Introduction: Demo Project Overview:
- [Instructor] In this course we'll imagine that we've been hired by Nadia's Garden Restaurant to build out their website. We've been provided with HTML, CSS, and image assets, but they want us to build a dynamic site with a custom admin tool for editing the menu, which is the part of the site that will change most frequently. We'll set up a new Laravel project and integrate the Nadia's Garden design. We'll build a tool to manage the categories and control their appearance on the home page. Then we'll integrate the category manager into a larger single-page application for managing the entire menu with client side routing using Vue Router and state management using Vuex.

All supported by a robust and secure Laravel backend. Including a flexible API that can be used by third-party sites or apps. So if you're ready to find out how we'll put all this together with Laravel and Vue.js, then I`ll see you in chapter one.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Installing Homestead:
- [Instructor] In this video, we'll begin to set up a complete development environment fr Laravel in Vue.js. On the Laravel.com home page, if you click Documentation up here, one of the first things that you'll see mentioned is Laravel Homestead. Homestead is a virtual machine, actually an Ubuntu Linux machine, that comes prepackaged with everything you need to build websites with Laravel in Vue.js and run them locally. Homestead is a Vagrant box, which means we'll be using a piece of software called Vagrant to create and manage this virtual machine.

On the Get Started page, they mention that Vagrant alone can't handle everything. We also need a virtualization provider to actually run the virtual machine that we're going to manage with Vagrant. One good option in this list that's available on multiple platforms is VirtualBox. If you're trying to follow along and you haven't worked with Vagrant before, you may want to pause the video here while you install Vagrant and VirtualBox because I won't be going through that entire process, and it's straightforward for most users.

If you do hit any snags, I would suggest first carefully reading this Getting Started page and following the links, especially the one here for install the latest version of Vagrant. But one common gotcha that you'll see mentioned in the Laravel docs is in this red section down here. If you're a Windows user, you'll need to make sure that hardware virtualization is enabled in your BIOS settings. Now we're going to head over to the command line.

I'll be using PowerShell in this course. And if you're also using Windows, I would strongly suggest that whatever terminal you're using, that you launch it by right-clicking and choosing Run as administrator. Also, before I forget, I have a shortcut for Visual Studio Code down here, which we'll be using in this course, and I want to right-click that and choose Properties, Advanced, and make sure that Run as administrator is also checked here because if you don't do this, you will probably run into issues later on with permissions when we have to create symbolic links in our project, which are going to help us manage user uploaded files, such as images for the menu that we're going to build.

So in PowerShell, the first thing that I'm going to do is change to my user directory with cd tilde. And then we can find the command for adding the Homestead box to Vagrant in the Laravel docs. If I scroll down a little bit more, it's Vagrant box add laravel/homestead. So I'm going to copy that and paste it into PowerShell. And it's going to ask us what provider we're going to use and we'll enter 3 for VirtualBox.

This could take a couple minutes, so if you're following along, you may want to let that finish before you go on to the next video. If you've used Vagrant before, and you're hitting any snags at this point, then making sure you're using an up-to-date version of both Vagrant and VirtualBox can usually help sort out most issues. Now that we've added the Homestead box to Vagrant, we'll take a look at configuring and booting it in the next video.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Configuring and booting the virtual machine:
- [Instructor] To finish setting up Homestead, next we need to clone the Homestead repository on GitHub because that contains scripts we need to configure our virtual machine and boot it. We can find that Git clone command in the next section of the Homestead documentation here. So I'm going to copy this, and bring it over to PowerShell, but if you're on Windows using the normal command prompt or PowerShell, don't put the tilde slash here because it will actually create a directory named tilde. Even though you can do cd tilde to change your user directory, that won't work.

So I'm going to clone it like that, and next, we want to check out the latest stable version which we can find on the release page for that repo, and there's a link to it right here. So it looks like it's 7.19.2. I'm going to copy that which corresponds to a Git tag name, and by the way, you could also find that with Git tag on the command line. Let's cd to our cloned Homestead directory, and then do git checkout using that tag as a ref name.

The last thing we need to do before we add our custom settings and boot the machine is initialize Homestead, and that means creating a new Homestead YAML configuration file. If we look in the directory right now, we don't see Homestead.yaml, but we do see these init files here. On Windows, we would want to run the batch file, init.bat, and on Mac and Linux, you'll generally want to do bash init.sh. So I'm going to run init.bat.

Homestead is now initialized, and if we look again, now we do see that Homestead.yaml file. Let's open that up in Visual Studio Code by typing code Homestead.yaml, and if code has been added to your path, that should work. I'm going to enable AutoSave before I forget so that I don't have to keep saving after every change, and in VS Code, we can open up an integrated terminal with control backtick, and again, this is PowerShell for me.

Now we're going to create a new directory called Nadias for our Nadia's Garden Restaurant website. We're doing this now so that we can tell Vagrant to sync the files in this directory with a corresponding directory inside the virtual machine when it boots up. That way, we can edit code in Visual Studio Code on our host machine, but run that code inside the virtual guest machine. So in this YAML configuration file, we can map that directory that we just created to Nadia's directory under our Linux user directory, and you can see that that user is named Vagrant.

For the domain name, something.test is common, but I tend to use a subdomain like dev, and for Nadia's Garden Restaurant, I'm just going to use dev.nadias. Mapping that domain to the public directory in our synced folder, again not code, but nadias, that will configure that as the root directory in an NGINX configuration file for that domain, which is what we would want for a Laravel site. You could leave the database name as is, but I usually change it to something meaningful, so in this case nadias again.

Finally, we need to make sure that the domain name we chose is mapped to this local IP address for the box up here, which I'm going to copy now. We can do that by editing our host file, and on Windows, that should be at c:\Windows\system32\drivers\etc\hosts. On Mac and Linux, it's a little bit easier. It should just be at /etc/host.

So now I can pace that IP address, and make sure that dev.nadias is mapped to that. Back in the YAML file, we'll need to be able to connect to the VM using SSH, but if you don't already have an SSH key in this folder, you can just comment out the key section with control/, and Vagrant will create and manage the keys for you. So now, again, if we cd to Homestead, we're ready to boot the machine with Vagrant up.

This sometimes takes a couple minutes, so you can pause the video now if you're following along, and I think I'll probably stop reminding you to pause videos all the time since you can probably figure out when you need time to catch up. Now that it's booted up, Vagrant SSH should get us to the bash shell in Homestead, and here we are. In the next video, we'll create a new Laravel project and set up an authentication system.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Scaffolding an authentication system:
- [Instructor] In Homestead, the Laravel installer is already set up for us so to create a new project we can just do, Laravel new nadias. Because our sync nadias directory already exists, we'll want to add the force option to allow it to overwrite that empty directory. Once this is done, we can already navigate to http://dev.nadias, and we should be able to see the default Laravel site. The first thing we'll want to do with our new project, is add it to the VS code workspace.

So from the file menu, I'm going to do add folder to workspace, and in my user directory I'm going to want nadias. You'll find that most backend related items are under App, but not everything. For example, we have the routes folder down here, and lets take a look at web.php. And this is where we define routes that you can navigate to in the browser. Here we have one route route, slash, which serves the welcome view, which you can find in resources, views, welcome.blade.php.

Before we start building out our restaurant site, we're going to generate some user related tables, and authentication system. From inside the homestead box, we can use the infinitely useful Laravel command line interface called artisan. So cd to nadias, and for this task, we just need to do artisan make:auth. Now, if we look at web.php again, we have a /home route, because that's where the user will be redirected after registration or log in.

Also notice that a call to auth:routes has been added, and that's going to set up the routes that are related to log in and registration. We also have some new views under resources, views, off. If I refresh the home page, and click this register link that appears now, and fill out this form, I'm going to get an error though. And that's because we still don't have a users table in our database.

And it's also using homestead for the database name, and remember we want it to use nadias, so lets fix that first. Under config in database.php, this mysql connection is going to be the default and we can see that it's using the environment helper method to get the database name, and using forge as the default if it can't find that environment setting. Changing the default from forge won't fix this, we actually want to change it in our .env file in the route directory down here.

So we're going to change DB_DATABASE to nadias like we wanted, and while we're in here, lets also change APP_NAME to Nadia's Garden Restaurant and make sure you put it in double quotes, and we'll also change APP_URL to dev.nadias here. Next, to create users table, we just need to run the database migrations that have already been prepared for us, which are in the database/migrations directory.

These are like sql scripts written in php. One for creating the users table, and one for creating a password reset tokens table. One thing I want to add in the users table script for later, is a column for indicating an admin level user. This is going to be a bullion column, called is_admin, and we'll make sure that it defaults to false. We run the migrations, with artisan migrate.

Now if I go back, and try this again, I've created a user, and logged in. So now I can register, log in and log out, and in the next video we'll talk about using forgot password, and setting up email verification.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Enabling forgotten password and email verification:
- On the login page, if I click forgot your password and try to submit this form, I'm going to see an authentication error. Because the default SMTP mail driver doesn't have a username and password set yet. But, there's an easy way to view the content of an email without actually sending it. And we can set that up in our environment file. I'm using control P to open that file even though it's right there in the route directory. And now, if we just change the value of mail driver from SMTP to Log, we can log emails instead of trying to send them.

So after refreshing and resubmitting that form, I can view the log. Which is in storage, logs, and it looks like there's just one log file that was created just now. And if I scroll down to the bottom, you can see the email that would be sent if we were using SMTP or perhaps an API. We can even click this link with control click and verify that this feature is working.

In Laravel 5.7, a new email verification feature was added, so that you can be confident that your users are using not only valid email addresses, but also deliverable email addresses. Because users will be required to click a verification link in an email that you send to them upon registration. But you do need to edit a couple files to enable it. So in our user model, in user.php in the app directory, we need to add the must verify email interface here.

Which you can see, has already been imported for you with this use statement here. That will trigger the verification logic on registration, and email a link to the user. Next, in our routes file, our web routes file, we'll need to register some routes for sending verification links and verifying emails when links are clicked. We can do that simply by passing an options array to this Auth routes call here. Where verify has the value true.

Let's try another registration now. I'm going to log out and do a new registration, with a different email this time, obviously. Since it has to be unique I'll use Michael instead of Mike. And at this point I'm logged in, but this new user is not verified yet. And if, for example, we wanted to restrict this home route to verified users only, we can just add the verified middleware to the route like this. Now if I refresh this page, I'm no longer authorized.

We could find that verification link in the logs, but lets see if we can do a little bit better than that this time. You may have noticed in my environment file that the default mail host is mail trap. This is a service that allows us to easily view all emails sent by our site in a web mail inbox. Because they'll all go to the same place regardless of the addressee. So, if we go to mailtrap.io you can sign up for a free plan, for an inbox that can hold up to 50 messages at a time.

Without a credit card. Which is great for testing. So if I click sign up I'm just going to use my google account. And then if I click demo inbox, you can see the username and password that we'd want to enter into our Laravel environment file. So I'm going to copy that and bring it over here. This is going to be the mail username. And this is going to be the mail password. And we need to remember to change mail driver, back to SMTP.

Now if I go back to this page and click, click here to request another, I should actually be able to see this email in my mail trap inbox even though I'm using an example.com email. And there it is. If I click it, now I'm verified and authorized to view this page. Next, we`ll finally start talking about view components while we take a look at Laravel mix.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Using webpack with Laravel Mix:
- [Instructor] Now it's time to take a look at Laravel Mix, which runs on top of the popular webpack module bundler to compile and bundle assets such as JavaScript files and C S S or Sass files. In our layouts file, we see asset here and here. That asset helper method returns an absolute URL with HTTP or HTTPS, depending on the current protocol. Those files are in public, js, and public css, and they're recreated whenever webpack processes changes in the corresponding files in the resources subdirectories.

In this case, resources, jsapp.js, and under sass, this app.sass file here. Let's look inside app.js. First, this loads bootstrap.js, which in turn loads a number of libraries and utilities like Lodash, jQuery, and axios. In app.js, we're also adding Vue to the global scope and registering a global component called example component which is in the components folder here.

And then of course down here, we're mounting our root view instance to a div with the ID app, which is in the layout file that we just looked at. Webpack can be pretty complicated, but configuring it with Laravel Mix is simple. In webpack.mix.js in our root directory, we see a call to mixes js method with a source and target directory. And then a chain call to the Sass method, again with a source and target directory.

Let's see if we can put example component on a page and then edit it. I'm going to accept this suggestion to install the Vidar extension down here so that we have syntax highlighting and error checking for our .vue component files. Once that's done installing, we can click reload to activate it and now we have some nice syntax highlighting for our Vue component file. Let's use the home view to test this and add this component right under this dashboard card here.

And now in the components template, we'll add a single word here and see if we can get it to show up in the browser. If I were to refresh after this change, I do see the component now, but not my edit. That's because webpack is not even running yet and of course the browser doesn't read .vue files on its own. Before we can get webpack running to compile our assets when they change, we need to install some front-end development dependencies.

You usually want to use npm to do that on your host machine because it'll be faster and you can do things like automatically launch browsers and trigger a refresh, which we'll see in the next video. So if you're in the homestead terminal right now, you can just do control + shift + back tick to open a new terminal on your host machine and then we can do npm install as long as we have no js installed on that host machine. Once npm install finishes, we can run webpack using npm scripts that are defined in our package.json file in our root directory.

For example, to run the dev script here, you would type npm run dev on the command line. But you can see that dev is really just an alias for development. That will do a one time development build, but watch is a little bit better for us because it will watch files for changes and automatically recompile them on the fly. So let's try that now. Npm run watch. And you can see it building modules and it's compiled successfully now and it's still running and watching for changes.

By the way, as you're working, if it seems like watch isn't picking up the changes to your files, you may want to try watch-poll instead. So once that's done compiling, I should be able to refresh and see my edit. And try a hard refresh with control + F5 if you don't see the change right away. In the next video, we`ll take a look at a way to avoid refreshing altogether.

Building Laravel and Vue.js Web Apps: Module 1: Installation and Configuration: Cache busting and Browsersync:
- [Instructor] We'll continue to explore Laravel Mix in this video, while we talk about cache busting, and browser sync. If I continue to edit this file, and then refresh the page, I might not see any changes because the browser will often get the App.js file from its cache. One way to avoid having that be loaded from the cache when there are new changes, is to add a query string with a unique hash to the file name. We can accomplish this by first just adding a call to the version method in our mix file.

In our lay-out file, remember I said that asset just creates an absolute URL, so if we also want to append the unique hash we'll have to change asset to mix here. And lets do that for App.js and App.css. We'll need to stop the running watch process with Control + C and then restart it. And now when I refresh, I see my original change, and if you do View Source you can also see that unique hash appended as a query string.

Let's test a change to our .sas file now. So in Resources, sas app.scss. If I just change this background color to yellow, and I'm going to use one of the variables that's defined in the variables file that sits right next to this one. When I refresh I get that yellow nav bar color, and I can also be pretty confident that a browser won't load an older version of this page when a user tries to refresh it.

Cache busting is really important in production, but we wouldn't really need it during development if we could automatically perform a full page refresh whenever files are changed. And it turns out we can do that. So we could reserve this just for production by saying if mix.inproduction, then only then do we use this versioning feature. And to enable the automatic reloading during development we just need to call mix.browserSync and pass in our local development domain, dev.nadias.

The reason we need to specify our domain here, is that we're actually going to start using a proxy server on the host machine that forwards requests to our homestead server, but also enables the injection of code in each page that can communicate with webpack and trigger the full page refresh whenever files are changed. So again when I stop this process and restart, you're going to see that it's automatically going to open the site through a server running on local host, now.

So I'm going to go back to the home page. That's fine that we're not logged in for now. And then I just want to line up my browser side-by-side with my editor and then back in the .sas file... Watch what happens when I change this back to the white color. So we have VS Code auto saving, then webpack auto compiling, and then the browser auto refreshing. And that's all pretty nice.

Webpack also has a feature called Hot Module Replacement. And that can inject updated modules without a full page refresh. Feel free to disable browser sync and try that by using npm run hot instead. It's a really great feature but I've found that it can be a little bit harder to get it working sometimes, especially when there are more moving parts to deal with, like in a Laravel project like this one where Mix is running on top of webpack. And the other great thing about browser sync, if I go back to the welcome page for a second, is that it can also automatically refresh after PHP changes as well.

So if I open the welcome view here, and just change this to the name of our restaurant site, and then go back to the browser, you can see it's already updated. In the next chapter, we'll start to integrate the Nadia's Garden design and assets and then start building out our View powered menu editor.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Integrating a Layout:
- [Instructor] In this video, we'll start to add the Nadia's Garden Restaurant branding to our Laravel project. In the Web Routes file, let's change this closure for slash to just return the home view, instead of that Laravel welcome view, which we don't need anymore. You can find the Nadia's Garden HTML assets in the exercise files for this video, so I'm going to add that folder to the workspace now, nadias_html.

So now, down here, in index.html, first, let's take a look at the head element here. For the title, let's just copy the restaurant name for now, and then, if I go over to our layout file, app.blade.php in layouts, let's change the default from Laravel to that, and of course, we're going to need to change these to double quotes, since we have that apostrophe there. But, it's going to get this app.name config value from the name key in app.php in the config directory, which uses that environment helper method to get the app.name value we set in the last chapter.

Then, over here, we can yield to a title section in the content pages that use this layout, in case we want to add a page specific part of the title, like a dash with the page name, or in the case of the homepage, this slogan here. We can also remove these font elements in the Laravel layout, and we'll add our favicon.

And, in index.html, let's copy just the URL for this font, and then, we can paste it right into our Sass file, in resources, sass. And we'll just replace this font that we're not going to use for the Nadia site. While we're in here, let's remove Bootstrap, which we're not going to use in this course, and this Laravel rule. You might want to leave Variables around, 'cause it could come in handy, even though we might not get around to using it in this course.

And then, in the nadias_html assets, let's just copy everything in this stylesheet right into our Sass file. So, now we can use Sass features with this CSS, and, for example, anything that begins with the top-bar class, I can nest under that first top-bar selector, and then, remove the top-bar part, like that. Let's also remember to copy the images folder from the assets, into the public Laravel folder, and that will make those images accessible with the source attributes that they already have.

Next, I'm going to remove everything from the Laravel layout file that we don't need, but I'll leave a few things behind, like for instance, this div with id="app" because we need that for our view instance to be mounted on. And, I'm also going to leave these authentication links here, like login, register, and logout, but I'm just going to remove these classes that are no longer available.

So, we have Login and Register, which will appear for guests. Otherwise, I'm not going to deal with displaying the account name for now, I just want the logout link. And you can see, that in Laravel, a logout is performed using a POST request, that's why this forum element is down here, so when someone clicks the logout link, it actually submits that form.

And I'm also going to leave this yield('content') here, because that's what's going to allow our content pages to extend this layout. Now I'm going to paste in this root div, from index.html. Not everything belongs in the layout, but we'll move it there for now. And then we'll start piecing everything together. I don't actually need this div, I just wanted to remember to put id="app" on the root div here, which also has class="container".

So now, let's grab those authentication links, and see if we can integrate them into the existing Nadia's navbar. So this should be fine like that, I just want to add another separator after Contact. Login and Register will appear together, since we do have a register route, so let's put a separator between those.

Otherwise, the Logout link will appear, and that all looks fine now. Now, everything between the two main tags, actually belongs in our home view, so that other pages can also use this layout. So I'm going to replace everything in the content section of our home.blade.php view, and then, back in the layout, between the main tags is where I want to yield to those content pages.

And also, in our home view, let's add that title section that I mentioned before, and instead of ending the section, I can just put the content right in there, like that. So, let's grab that slogan from index.html, and we'll put that in there. Now, if we check the browser, we see our branded homepage, and we can start adding some dynamic behavior to it, over the next few videos.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Creating a model and seeding the database:
- [Instructor] The first thing we'll do with our new homepage is change this section so that the category names and image file names are pulled from the database. So, switch to your homestead shell if you're not there already, by using this dropdown. And we'll use artisan to create a model called category, so artisan make:model Category. And then, with the M and R options, we can also generate at the same time a migration for creating category table in the database and a resource controller with some basic CRUD actions.

So, in my app folder now, I have this category model, and it doesn't need anything else for now except what's provided in the base model class. And in HTTP controllers, in my category controller, I won't use all of these methods, but it's nice to have this shell as a starting point. And then in database migrations, I have this new migration file. And here I'm going to add name and image columns for the category table.

So these will be string or a VARCHAR in MySQL, and we're going to use the default settings for name and image for the image file name. I'll also add a display order column to control the order of the categories on the homepage and on the menu. So this can just be an unsignedTinyInteger, and we'll call it display_order, and that's perfectly appropriate for ordering a small number of items.

And of course, time stamps will add those created-at and updated-at time stamp fields. So now we can run artisan migrate, and we should have a new categories table in our database. We're going to build an admin interface shortly to manage these categories, but for now, we'll use a seeder to get some test data in our new table. So, we can create a new seeder with artisan, artisan make:seeder, and we'll give our seeder class a name like CategoriesTableSeeder.

Now, inside that file that's going to appear in the seeds folder under database, I can use the DB facade with the categories table and call the insert method passing an array of arrays that each correspond to a category model that I want to insert. So for my first category, the name was Starters, and for image, we can assume that this file already exists in the public images folder for now to keep things simple.

Display order is going to be one, and we're not going to worry about created at and updated at for now, although those will be automatically taken care of when we're actually saving models in our app. So let's copy this a couple more times and just add two more categories for now. We'll do Salads, and we should have an image called salad.jpg. Display order will be two. And then Entrees, and if you remember, that one was a picture of a burger.

Display order will be three. And we're going to leave out the desserts' category for now because we'll insert that using our admin tool later. To run this seeder, we could call artisan db:seed and give it the class name with the class option, or we can just run artisan db:seed if we add it to the database seeder. So, we could just uncomment this and change users to categories.

And by the way, if you don't create the seeder with artisan, and you're just starting from the exercise files, you might need to run composer dump-autoload for it to be able to resolve the categories table class name. Otherwise, you should just be able to run artisan db:seed now. And then we can verify that everything looks good in MySQL. Select star from categories. And there they are.

And in the next video, we'll display this data on the homepage.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Building views with Blade templates:
- [Instructor] Now we'll finish up our restaurant home page by using blade templating to display the categories from the database. Let's remove this slash route here and we'll want to use a home controller method to prepare the data for the home view. So we'll just change home to slash here so that we can serve the home page right on the bare domain like we were doing before. And we don't need the verified middleware here since we don't care if users viewing the home page are verified or even authenticated.

Now in various controllers, such as the login controller, there are places where it redirects the user to home but since we don't have home anymore I'm going to use Control + Shift + H to find and replace and I'm going to look for equals space slash home end quotes and just replace that with slash. So if I hit enter now I see the places in these various controllers where the redirect to property is set and I'm going to click this to replace all.

And now that's taken care of. In home controller now, if we go over there we also don't need this off middleware here since again we don't care if someone is authenticated for the actions in this controller. Now in the index method, let's grab all the categories and store them in a variable. So we'll do category and we could use the all method here. But if we want all of them and we want them ordered we can just use order by. And remember we're going to be ordering by our display order column.

And then we'll just call get. Now we want to provide an array of parameters to the view which for now will just be categories categories. Now let's go over to the home view. And we'll make these categories, these article elements dynamic. I promise we'll get into using Vue very shortly, actually in the next video but there's really no reason to use Vue here because although the categories are data driven we don't really have any interactive or dynamic behavior once the page is loaded.

So if I remove all of these articles except one then I can wrap this is a four each using blade syntax. And then we can iterate over the categories. And I'll use cat as my looping variable. So for the HREF attribute for the image, this is going to be a link to slash menu with a fragment identifier that points to a named anchor that we'll set up later. And then inside the double curly braces we just need cat name.

And actually I'm going to use the string slug helper method to change spaces to hyphens and otherwise URL-ify this whole string. So let's copy this HREF attribute to the text link as well. And then for image, we want to keep the slash images and then remember cat image will give us just the file name. And we'll want to do an end for each down here and maybe indent that to make it a little easier to read.

So now let's look at the home page. On the home page now, I see an error because this category class wasn't imported into the home controller. So I'm going to need a use declaration at the top of home controller for category. Otherwise I'll need to do app category. Since adding use declarations is sometimes tedious and error prone, I'm going to install an extension to help with that and also provide IntelliSense and auto completion for PHP.

You'll find most PHP extensions aren't perfect but they will save you some time. So Control + Shift + X to look at extensions and I'm going to search for PHP IntelliPhence with a P-H in the middle. So I'm going to install this one and reload to activate. And you might have to wait a minute for it to do some indexing. But then if I retype category I should be able to hit enter now and I'll get my use declaration at the top there.

You'll also want to do control comma to edit the settings for PHP and disable the basic suggestions in VS code so they don't interfere. Also I don't have PHP installed on Windows, so you may have noticed that message about not being able to validate against a specific PHP installation, and that's fine for now. And if webpack was running, then usually when you reload you'll lose that running process. So let's just do NPM run watch again.

And now we have our homepage with three out of our four categories, but loaded from the database. And in the next video, we'll start to build the admin UI for updating this data.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Injecting props in Vue components:
- [Instructor] In this video, we'll start to build out the Vue.js powered admin tool for updating the restaurant's menu. Because we'll always have a relatively small number of menu categories, and they have a simple set of attributes, we don't really need separate pages for listing, creating, and updating these category records. We'll do it all in a single page using Vue.js. So I'm going to start by copying the body of this method in the home controller into the index method of the category controller that we created.

But this time instead of home, we'll return a new index view that we'll create inside a categories folder, inside an admin folder. We can actually create those new folders in the view all in one shot if we go to resources, view, New File. I can now do admin categories index.blade.php, and it will create that folder structure for me in the new blade file. And let's copy some of the blade directives from home to get us started.

And we'll remove that slogan and just say Categories for the second part of the title. And of course, we're going to want to do endsection here. And for now, we'll just put a level one header that says categories. In our Web Routes file, I'm going to add a Route for /categories that responds to get requests. And those will just be forwarded to that method so Category/Controller@index, and we'll skip the name for now.

We need to be able to do things like add a new category to the list inline or delete a category. And we'll do that all inside a Vue component called category manager. So this is actually all we'll need in our blade view. And by the way, if you don't get that auto closing tag in PHP files, try the Auto Close tag extension, the first one in the list right here, and that will also enable it for Vue files, which is nice.

In resources, js, components, let's create CategoryManager.vue and we'll start with the template. We need to make sure we have a root element, like a div, and then we can put another div inside that and repeat it with a v-for directive to iterate over the categories. So we can do category in categories. And then for now, we'll just display the name.

And remember the double curly braces here, that's vue string interpolation, not to be confused with the similar blade interpolation. We should also provide a unique key for each element to help Vue manage them more efficiently and id is fine for that here. But where does this categories array come from? Well, in the scripts section, where we export the component options, we can declare categories as a prop that will be provided to the component in the view.

But first in app.js, let's just change example component to category manager to get that one registered quickly, since we won't be using example component anymore. And make sure our web pack is still running, of course. When I look down at my terminal, I can see that it is, and now in the view, all we have to do is inject categories as a dynamic prop. Remember to use v bind or the colon in front of categories, since we're not passing a little string here, but an array of categories.

The nice thing here is that all we need to do is put our PHP variable categories inside the double curly braces. And this will actually call JSON in code automatically and properly double in-code HTML entities to avoid any syntax issues. So it really doesn't get much easier than this to pass an array from PHP to JavaScript. So now in the browser, if I just navigate to categories, I can see our category manager component and the list of categories.

In the next video, we'll start building out the UI for the basic CRUD functionality.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Building a CRUD component:
- [Instructor] Now we'll start turning this view component into a form for managing the category records. We'll want to be able to add to, edit, or delete the categories in this prop, but it's a bad practice to mutate props, since our changes can easily be overwritten by a parent component. Here we don't have a parent component, but we will later on, and even if that parent component won't be updating the data, we'll be better off if we don't get in the habit of breaking this rule. So first, let's give this component its own data.

We'll change the prop name to initial categories, both in the component and in the blade view, and in an html template, I want to use Kebab case like that. Then, we'll just initialize a data property called categories with this dot initial categories as its default value, but because a raise in objects are passed by reference in Javascript, this won't prevent us from mutating the prop at all, since categories is now just a reference to the same initial categories array.

So to really avoid mutating the prop, we'll clone it. Lodash is already available in the global scope, so we can use the Lodash clone deep method underscore dot clone deep to clone the array and recursively clone each category object in the array. Now up in the template, let's change our root element to a form and inside the loop, we'll create input elements for each attribute.

So first, we'll have a couple of basic fields for name and display order. In these we'll use two way binding with v model, so for name we'll have category dot name and then for display order, we'll make type a number, and v model will be category dot display order. We'll follow those fields with a link to delete the category, so at click sets up an event handler.

This is going to call the remove category method which we'll set up in a moment, and we'll pass it the index of the category to remove in the array. I'm also going to add class remove just to give it a little bit of styling, and the link we'll say delete. But, if we want to use this index which isn't defined, we need to add it to the v for like this, category index in parens.

Next, we'll open up a new section and we'll show the image using an image tag with a dynamic source attribute. I'm going to use an ES six string template here since we need slash images before category dot image, also add a width of 100 to constrain it a bit just so it doesn't blow up the page. We will be looking at file uploading later on, but I don't want to get bogged down with that right now, so, we're just going to provide a text field for setting the image file name.

And we'll assume that anything that's entered there will already be available in our public images directory. We'll also add a horizontal rule at the end to help separate the categories visually. Now down in the script section, we'll add a methods object, and the remove category method will be simple for now. It will take the index of the category to remove from the array, and we will add an API to talk to our Laravel back end soon, but for now, we'll just use a confirm dialogue, we'll say, are you sure, and then we'll just remove one element from the array using the splice method at that index.

Remember, we can also add a style tag in a view component. So here, I'm just going to be setting the alignment for the image and the elements around it, and also adding a margin below the horizontal rule. And since these are really simple selectors, I'll probably want to add the scoped attribute to make sure that these rules only apply to this component. So now if we look in the browser, we have a form for updating categories and we can remove one, or at least remove it from our view data, if not from the database just yet.

In the next video, we'll add the ability to create a new category, and look at some issues that come up with the UI and UX there.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Managing scrolling and focus:
- Continuing from where we left off, let's make sure that we have a way to add a new category now. We'll do that with a link at the top that invokes the add category method. And class equals add is just going to add some basic styling that's defined in our SAS file. For the link text, we'll just do plus and then add category. So, down in methods now, all that this add category method needs to do is push a placeholder object onto the array.

So we'll do this dot categories dot push and then this ID of zero, later on, this will indicate to our laravel backend that we need to store this as a new category. Name and image will be empty strings but display order can default to one more than the current number of categories. Since the placeholder won't have an image yet, let's only display this image tag if category dot image isn't empty.

Otherwise, we'll put a label here with v-else so that the user knows what's expected. So, now if I look at the browser, clicking the add category link does create a blank category at the bottom, but it would be nice if it could automatically scroll to the bottom and also focus the cursor on the name field. So in addCategory, we can use some vanilla javascript for the scrolling. Just window dot scrollTo with zero as the X coordinate and the body scroll height as the Y coordinate.

But we'll want to give the dom time to update and insert the new div before we scroll so we can wrap this in a callback to nextTick like this. For focusing the cursor, that's a bit more complicated. On the name field, we can add a dynamic ref so that we can access the dom element using the category name.

For a new category, the ref name will just be an empty string. But when a ref is created inside a V-for like this one is, it's always an array, even if there's only one element with that ref name. So we'll access it with this dot dollar sign refs, the ref with empty string as its name, which is an array and then the first item at index zero. And then we can call focus.

This is one thing that's much easier in jQuery. But normally you shouldn't need to access the dom directly and focus is just a special case where we can't bind the focus to our view model in any simple or straightforward way. We're not connected to the backend for adding categories yet but let's test adding that missing desserts category just in the front end. So now I have my scrolling and focusing on the name field. We'll add desserts. 4 is the display order I want and I know we have brownie dot jpg in the public images folder.

So, it's nice that the image appears right away but that was a little messy with those intermediate states before we finished typing. To fix that, we can use the lazy modifier on v-model for the category image so that we're syncing after the change event instead of after the input event on every keystroke. So now if I try that again, I have to tab away from this field before you see the image. Which is a little cleaner.

Before we build this admin out too much, it's a good idea to think about protecting this page from access by non-admin users, which we`ll talk about next.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Protecting routes and models with policies:
- [Instructor] For permissions that need to go beyond simply requiring authentication or email verification, we can create what are known in Laraval as policies. In this video, I'll create a policy for actions on the category model, and we can do that with Artisan of course. So artisan make:policy. We'll give it a name like CategoryPolicy, and then using the model option, we can specify the model class name for the model that we want to define these permissions for.

So now we can open that up in app policies, category policy, and we can add logic for all of these different actions, and return either true or false for the current user to indicate whether or not they're allowed to perform the given operation. By itself, this won't have any effect because it will need to add code that checks this policy in a controller, or a route, or even in a Blade template. For our purposes, all we really care about is whether or not the user is an admin, but it's nice to have all these methods ready to go if we want to get more granular with our permissions later on.

So, for example, if we're checking the view action, we could just return whether or not the user is an admin, and we could do that in each method, or we could add a before method that will cause this to be checked regardless of the permission we're authorizing. So this is going to take a user and an ability that corresponds to one of the method names below, and this time we don't just want to return whether or not the user is an admin because if they're not an admin, we don't want to do anything yet.

We want to let it check in the normal way, but if they are an admin, we're going to return true, and that means that, for an admin, all the permissions defined in this policy will automatically resolve to true, and the other empty methods will resolve to false by default for non-admins. And we don't have a page for viewing a single category, so I might change this one to manage to be used as a check for access to the category admin page.

We also don't really care about checking any specific instances of category to authorize somebody to look at that page and to manage the categories. So this is going to be determined whether the user can manage categories. Before we can use this logic, we need to register the policy in AuthServiceProvider in the app provider's folder. So that one there is just there as an example, so we can copy that, and say that whenever we check a permission for an operation on a category model, we'll be using this policy that we just created.

Now let's see if we can prevent the user from accessing our category manager page, and then when we make them an admin, we'll verify that they can see it, sort of like a red-green test. So now, in our category controller, in the index method, we can just call this authorize, passing the action name, which is going to be manage, followed by an instance of a model, or in this case, just the model's class name.

So now when I look at the browser again, I'm not authorized to view this page anymore. Now, I want to make sure I'm logged in here, and I am, but go head and log in if you're not logged in. Otherwise, these methods will just return false by default. And notice, back in the policy, if I just return true here, now it's going to let me in, but we only want to let admins in so let's remove that, and let's make my user an admin.

So let's get back to the homestead shell, and for this, we can use artisan tinker to query the database and update records on the command line. So I happened to know that I'm logged in as the user with ID one, so I can do that, and just set is_admin to true now, and remember to call user save. We actually do need to manually refresh this time because changes in the console aren't going to trigger a browser-sync refresh, but when I refresh, I can see I'm again authorized since I'm an admin.

In the next video, we'll build an API for category actions which will allow us to finish the category manager component.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Building an API with Laravel Passport:
- [Instructor] In this video, we'll build an API with token authentication using Laravel Passport. For actions that will invoke with Ajax, we could put the routes here in web.php and rely on the same cookie-based sessions for authentication, but it's nice to keep them separate in this API routes file which is in the same folder. This API guard used here uses token authentication by default, and it's also nice to build a universal API with that token authentication in case you need it later, for instance, for a completely separate app, web or mobile, or for third party integrations with your system.

We can setup an API without much effort at all using Laravel Passport which is a complete OAuth2 server and API authentication package. You can install it with composer. Just type composer require laravel\passport. Passport comes with migrations, although they won't be placed in the normal migrations folder. So next, we'll run artisan migrate to create the tables to store the API access tokens.

To get everything else we need in order to generate the access tokens, we'll run artisan passport install now. Next, in our user model, we'll need to add the HasApiToken straight here and I wish I could tell you why it's not giving the IntelliSense suggestions right now because we do need to add a use declaration up here for Laravel\Passport\HasApiTokens.

We'll also need to add the create fresh API token class to the web middleware groups and we can do that in http\kernel. So from my web middleware groups, this one is going to be \Laravel\Passport\Http\Middleware\ CreateFreshApiToken and we want the class name there. We're almost there, but now we need to change the driver for the API guard and we're going to find that in config/auth so if I go down to the guards here, I want to change the driver for API from token to passport now.

Back in the API Routes, let's change this to a route that we'll use for storing our categories. This will be at /categories/upsert and any URLs in here are going to start with API implicitly. So when we call this from view, we're actually going to have to do API/categories/upsert. And then, instead of a closure here, let's forward this to a new method that will create in CategoryController and we'll call it upsert because we're either updating or inserting new categories on our page.

Since we want every route in this file to use the API authentication, let's remove this middleware and we can just add it to the API middleware groups in kernel here. So just add auth:api here and then, one more thing, I want to change this to post here. And now, let's go to the category controller. We'll add the upsert method below index and let's copy this authorized line here to check for permissions with the manage action but for now, we'll just return an array where success is true.

'cause I just want to see if we can get everything working together. The quickest way to test this to see if we set it up right is in our view component category manager, let's just call our API endpoint in a created hook. So this will be axios.post to /api/categories/upsert and that's all we'll put in this file for now and then, if I go over to the browser and open up the dev tools with F12, I want to look at the Network tab and XHR for Ajax requests and responses and if I refresh, I can see upsert with the status of 200 and if I click that, I can see the response body with that success true that we were looking for.

Next, we'll add a button to save categories and build out the upsert method in our controller so that we'll have a full working category manager.

Building Laravel and Vue.js Web Apps: Module 2: MV* Architectures: Calling an API from Vue:
- [Instructor] Before we start making calls to the API from our Vue component, we'll need to build out this upsert action in the Category controller a bit. First, let's inject the incoming request which we can do by just creating a parameter of type, Request. We're going to need this to update all existing categories and store any new categories. We'll just be posting our categories data property from the component, so we can store that for categories, and we can access that now with request, post, categories, like that.

Then we'll loop through them, for each categories, and again, I'm going to use cat as a looping variable, and we can say, if the ID isn't empty, or isn't zero, then we can use the Category::where method to find the category that has that ID, and then we can call update, passing that cat array of keys and values that we want to update for that model.

Otherwise, we can just call Category::create, passing the same array of keys and values. Since Vue needs to be made aware of the IDs of any newly created categories, so that they're submitted with those new IDs on subsequent requests, let's just return the latest collection of categories and we'll just get all of the latest from the database with Category::all. And then, in the Vue component, we can just update them all at once in the Vue model after saving.

We're going to cheat a little bit on validation for now, but we'll talk more about it later, but in the category model, let's just add an empty guarded array, to indicate that we'll allow every property to be mass-assignable for those create and update methods. Otherwise, we would need to specify all the assignable properties individually, by setting the fillable attribute array. Let's get back to our Vue component now.

We can remove the created hook here, and then let's finally add a submit button, which our form doesn't have yet, so button type, submit, and we'll just say Save, and underneath that, we're also going to add a feedback section. This is going to display the value of a new data property called feedback, which will just show a message whenever saving is complete, so let's add that in data along with categories.

We'll initialize it to an empty string, and then we'll add a submit handler for the form, so @submit, and we'll use the prevent modifier to avoid the browser's default form submission behavior so that we can use Ajax instead inside this saveCategories method, which we can write now. So down here, let's add saveCategories.

Again, we'll use axios.post() to api/categories/upsert, but this time, we'll send the categories data, which is just this.categories. This should return a promise, so in the callback, we can accept the response, and then we can check that success key, and that's not going to be in res, but in res.data when we're using Axios.

So if that's true, we can set feedback to something like, changes saved, and now we also want to set categories to res.data.categories, and that's to make sure that we're synced with the database and we have the IDs of any newly inserted categories in our view data, because if you don't do that, and you've hit Save multiple times, you'll start getting duplicate categories being created.

So let's test this now by adding the Desserts category for real, so Desserts, and remember, that was brownie.jpg, and I'm also going to change Salads to Salad so that I can test that update is working as well. So I see changes saved, and if I go up here and click the logo, I know it's really saved because now I see the Desserts category on the home page, and Salads was changed to Salad. Let's also get delete working, and then we'll be done with this component.

So in our API routes, not the web routes, we're going to add a route that responds to the delete method, and that's going to be categories, slash, and then a parameter for the category. This will actually be an ID, but if I call it category instead of ID, we can use route model binding to have it automatically look up that category and pass it to the controller method, and that controller method is already set up for us.

It's destroy, and that's already set up for us in the category controller that we created earlier in this chapter, and then, in the destroy method, let's go down to that in the category controller. We'll authorize the delete action and if you look in the category policy, this takes a specific instance of a category model. Again, an admin will always have permission to delete, but if we want to allow other users to delete later on, we might want to examine the category first, maybe to see who created it, and now we'll be able to add that logic easily.

So then, since we already have the category injected, we'll just call delete, and we'll return success true. Now, back in our component, we need to finish the removeCategory method. If they're sure, let's grab the ID of the category at this index, so this.categories[index].id, and if ID, or we can say if ID is greater than zero, only then do we need to call the API and delete this, because we might add a blank category and then decide to delete it.

In that case, we can just do splice, without calling the API. But if it is an already saved category, we want to do axios.delete, api/categories/, don't forget the slash, and then do plus ID. So sometimes those ES6 string templates are a little bit ugly there. In this case, I think it's easier to just do plus ID, and let's test that. Go back to our categories component, and if I delete that one that I just created, are you sure, okay.

Let's go back to the home page again, and it's really gone. In the next chapter, we'll integrate this component into a larger component for managing the entire menu, using client-side routing with Vue router.


